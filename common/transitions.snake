"""
The idea here is that we have many short chains of rules that 
recur in many places and can build up self explanatory file names

BUT...

Often when we combine them, trying to encode the full workflow in filenames
quickly becomes impractical. 

If we use a symblic link, though, the output of one set of rules with a complicated name, can also be the simply named input of another set of rules.

Another use if for when the input file is in another part of the file system. We can link it to a simply named file to start the workflow.

We can also concat multiple files into one here by giving list of files
"""
logger.debug("BUILDING TRANSITIONS")
from paramiko.ssh_exception import AuthenticationException
from snakemake.remote import AbstractRemoteProvider

url_rexp = re.compile(r'^([A-Za-z]+)://(.+)$')
mnt_rexp = re.compile(r'^(/mnt/([a-z]+ine)/.+)$')

providers = {}
def get_provider(protocol, host):
    """
    Creates a unique RemoteProvider object for each (protocol, host) pair.

    Connection options taken from:
    config['remote'][protocol][host]

    With defaults from:
    config['remote'][protocol]['defaults']

    protocol must be one of SFTP, SCP, HTTP, HTTPS, FTP, but case can be
    different. Case is used when keying options, though, so be consistent in
    your configuration
    """
   
    provider_key = (protocol, host)
    protocol = protocol.upper()
    if provider_key not in providers:
        remote_defaults = config.get('remote', {}) \
                                .get(protocol, {}) \
                                .get('defaults', {})
        remote_defaults.setdefault('keep_local', True)
        remote_options = config.get('remote', {}) \
                                .get(protocol, {}) \
                                .get(host, {})
        apply_defaults(remote_options, remote_defaults)
        logger.debug("Creating RemoteProvider for {protocol} "
                     "using:\n{remote_options}".format(**vars()))
        if protocol in ['SFTP', 'SCP']:
            from snakemake.remote.SFTP import RemoteProvider as sftp_rp
            providers[provider_key] = sftp_rp(**remote_options)
        elif protocol in ['HTTP', 'HTTPS']:
            from snakemake.remote.HTTP import RemoteProvider as http_rp
            providers[provider_key] = http_rp(**remote_options)
        elif protocol == 'FTP':
            from snakemake.remote.FTP import RemoteProvider as ftp_rp
            providers[provider_key] = ftp_rp(**remote_options)
        else:
            raise Exception("Remote protocol {} not yet supported"
                            .format(provider_key[0]))
    return providers[provider_key]

def get_transition_input(transition_file_name):
    """
    return input file based on output.
    add remote wrappers if needed
    """
    source = config['transitions'][transition_file_name]

    try:
        # is it an explicit url
        # (EG: SFTP://lys.soest.hawaii.edu/mnt/lysine/...)
        m = url_rexp.search(source)
        if m is not None:
            # replace source file with a remote object
            protocol, source_path = m.groups()
            host = re.search(r'^([^/]+)/', source_path).group(1)
            source =  get_provider(protocol, host).remote(source_path)
            return source

        # special case: delong lab remote mounts
        m = mnt_rexp.search(source)
        if m is not None and not os.path.exists(source):
            protocol = 'SFTP'
            config.setdefault('remote', {}) \
                  .setdefault(protocol, {}) \
                  .setdefault('defaults', {'username': 'readonly'})
            source_path, server_name = m.groups()
            host = server_name + config.get('remote', {}) \
                                       .get('domain', '.soest.hawaii.edu')
            source_path = host + source_path
            source =  get_provider(protocol, host).remote(source_path)
            return source

    except Exception as e:
        print("Error in transitions: " + repr(e))
        raise e

    logger.debug("Input for {} is {}".format(transition_file_name,
                                             str(source)))

    return source


# To prevent trying to copy or link from a file to itself
#  remove redundant transistions here (prefilter URLs so we don't trip os.path)
logger.debug(config.setdefault('transitions', {}))
transitions = {s:get_transition_input(s) \
                   for s,t in config['transitions'].items() \
                   if url_rexp.search(s) is not None \
                   or os.path.abspath(s) != os.path.abspath(t)}
logger.debug(transitions)
config['transitions'] = transitions

def get_link_or_cat_command(wildcards):
    """ choose 'ln -s' for single files, cat for multiple. Also use abs paths """
    input_files = transitions[wildcards.transition_file_name]
    if isinstance(input_files, AbstractRemoteProvider):
        logger.debug("Linnking to remote file: " + input_files)
        input_files = str(input_files)
    if isinstance(input_files, str):
        # Single input file, just link it
        #return "ln -s {}".format(os.path.abspath(input_files))
        input_file = input_files
        return "ln -s $(realpath --relative-to=$(dirname {}) {})".format(
            wildcards.transition_file_name,
            os.path.abspath(input_file)
        )
    # otherwise, we have a list of files to concatenate
    return "cat {} >".format(" ".join(os.path.abspath(f) for f in input_files))


# To prevent transition rule from matchin every file on earth:
#  dynamically generate overly specific regex constraint that lists all file names
pattern = "(" + "|".join(transitions.keys()) + ")"
wildcard_constraints:
    transition_file_name=pattern

# transition rule will only match one of the configured files
localrules: transition_link_or_cat

rule transition_link_or_cat:
    """ Creates a symbolic link to or concatenates files from a config mapping """
    input: lambda w: transitions[w.transition_file_name]
    output: "{transition_file_name}"
    params:
        command = get_link_or_cat_command,
    shell: "rm -f {output} && {params.command} {output}"

