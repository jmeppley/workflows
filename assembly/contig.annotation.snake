"""
Rules that take a contigs.fasta file and generate a bunch of information about
the assembly

 * basic stats
 * assembly stats (N50, etc)
 * identify rRNA genes
 * predict proteins
 * annotate proteins
 * compile summary stats and annotations
"""

include: "../common/mapping_bwa.snake"
from python.common import get_file_name
from python.assembly import get_contig_stats, \
                            generate_histogram

"""
# Some extra hoops to jump through because the contigs stats aren't a proper 
#  script yet
snakefile_path=os.path.dirname(os.path.abspath(workflow.snakefile))
config['pymg_dir'] = os.path.join(snakefile_path, 'tools', 'pymg')
sys.path.append(config['pymg_dir'])
from edl import __version__ as PYMG_VERSION
"""
include: "contig.genes.snake"
include: "rrna.annotation.snake"
include: "../annotation/lastal.snake"

config.setdefault('outputs', set()).add("contigs.filter.annotations.gff")
config.setdefault('outputs', set()).add("contigs.filter.annotations.fna")
for sample in config['sample_data']:
    if 'clean' in config['sample_data'][sample] or \
            'raw' in config['sample_data'][sample]:
        config['outputs'].add("contigs.all.annotations.coverage.{sample}.tsv"\
                                        .format(sample=sample))

rule contig_stats_table:
    """
    Make a table of contig sequence stats (length, gc)
    """
    input:
        "contigs.all.fasta",
    output:
        temp("contigs.all.sequence.stats.txt"),
    benchmark:
        "benchmarks/contig.sequence.stats.time"
    run:
        get_contig_stats(get_file_name(input), get_file_name(output))

rule contig_master_stats_table:
    """
    Merge sequence and coverage stats into one table
    """
    input:
        seq="contigs.all.sequence.stats.txt",
        cov=expand('contigs.all.coverages.{sample}.txt', \
                   sample=[s for s in config['sample_data'] \
                             if 'clean' in config['sample_data'][s]])
    output:
        'contigs.all.stats.txt'
    benchmark: 'benchmarks/contigs.stats.time'
    run:
        # load sequence stats
        contig_stats = pandas.read_table(get_file_name(input.seq), index_col=0)

        if isinstance(input.cov, str):
            input.cov = [input.cov, ]
        # merge in coverages from each sample
        for cov_file in input.cov:
            sample = re.search(r'coverages.(.+).txt$', cov_file).group(1)
            cov_stats = pandas.read_table(cov_file, index_col=0)
            cov_stats.columns = ["_".join([sample, c]) for c in cov_stats.columns]
            contig_stats = contig_stats.join(cov_stats, how='left')
            # add up read count and mean cov from all samples
            if 'ReadCount' not in contig_stats:
                contig_stats['ReadCount'] = contig_stats[sample + "_ReadCount"]
                contig_stats['MeanCov'] = contig_stats[sample + "_MeanCov"]
            else:
                contig_stats['ReadCount'] = contig_stats['ReadCount'] + \
                                            contig_stats[sample + "_ReadCount"]
                contig_stats['MeanCov'] = contig_stats['MeanCov'] + \
                                            contig_stats[sample + "_MeanCov"]

        # write table to file
        contig_stats.to_csv(get_file_name(output), sep='\t')

rule contigs_filter:
    """
    Get list of contigs that pass provided filter:

    Filter defaults to:
        ReadCount>=5
        Length>=2000
    """
    input: "contigs.all.stats.txt"
    output: 
        list="contigs.filter.list",
        table="contigs.final.stats.txt"
    benchmark: 'benchmarks/contig.filter.list.time'
    params:
        cutoffs=config.get('contig_cutoffs', ['ReadCount>=5',
                                              'Length>=2000']),
    run:
        contig_table = pandas.read_table(get_file_name(input), index_col=0)
        for filter_string in params.cutoffs:
            contig_table = contig_table.query(filter_string)
        contig_table.to_csv(get_file_name(output.table), sep='\t')
        with open(get_file_name(output.list), 'wt') as OUT:
            OUT.write('\n'.join(iter(contig_table.index)))
            OUT.write('\n')

rule contig_histogram:
    input:
        "contigs.all.stats.txt"
    output:
        "histograms/contigs_gt_{length_cutoff}/{metric}.hist"
    params:
        width=75,
        log=True
    run:
        generate_histogram(get_file_name(input),
                           get_file_name(output),
                           metric=wildcards.metric,
                           length_cutoff=int(wildcards.length_cutoff),
                           txt_width=params.width,
                           log=params.log)

rule contigs_filtered:
    """
    Get fasta of contigs with config[mapped_read_cutoff] mapped reads
    """
    input: 
        fasta="contigs.all.fasta",
        list="contigs.filter.list"
    output: "contigs.filter.fasta"
    benchmark: "benchmarks/contigs.fitered.fasta.time"
    shell:
        "screen_list.py -k {input.fasta} -l {input.list} -o {output}"

rule annotation_coverage:
    """
    For each annotation, pull out the median coverage for its contig
    into a simple two column table
    """
    input:
        gff="contigs.all.annotations.gff",
        stats="contigs.all.stats.txt"
    output:
        table="contigs.all.annotations.coverage.{sample}.tsv"
    run:
        # Read stats table, but just keep median coverage
        cov_dict = pandas.read_table(get_file_name(input.stats),
                                     index_col=0,
                                     usecols=['Contig', config['cov_col']])\
                                                             [config['cov_col']]
        with open(get_file_name(output.table),'w') as OUT:
            with open(get_file_name(input.gff)) as GFF:
                current_contig = 0
                for line in GFF:
                    contig, program, model = [bit.strip() \
                                              for bit in line.split(None, 3)[:3]]
                    if contig != current_contig:
                        # reseet counts
                        gene_count, rrna_count, trna_count = 0, 0, 0
                        current_contig = contig

                    # is it a CDS or RNA
                    if program.lower().startswith('prodigal') and model == 'CDS':
                        gene_count += 1
                        suffix = "_{}".format(gene_count)
                    elif program == 'cmsearch' and re.search('rRNA', model) is not None:
                        rrna_count += 1
                        suffix = "_rRNA_{}".format(gene_count)
                    elif program == 'cmsearch' and re.search('tRNA', model) is not None:
                        trna_count += 1
                        suffix = "_tRNA_{}".format(gene_count)
                    else:
                        raise Exception("Can't classify GFF line:\n" + line)

                    # Write fasta to OUT
                    OUT.write("{contig}{suffix}\t{coverage}\n"\
                               .format(contig=contig,
                                       suffix=suffix,
                                       coverage=cov_dict[contig]))


