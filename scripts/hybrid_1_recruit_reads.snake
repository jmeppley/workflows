import os, sys, re, glob, pandas, itertools

data_dir = config.setdefault('data_dir', '..')

# find all the MG genomes
mg_genome_fasta_files = glob.glob(data_dir + "/*/*/*/contigs.fasta")
mg_genomes = {}
mg_bams = {}
for fasta_file in mg_genome_fasta_files:
    rundate, sample = \
        re.search(r'/(\d\d\d\d\d\d)[_-]NS500.+/([^/]+)/contigs.fasta', \
                  fasta_file).groups()
    sample_name = sample + "-" + rundate
    mg_genomes[sample_name] = fasta_file
    mg_bams[sample_name] = glob.glob(re.sub(r'contigs.fasta','mapping/*.reads.vs.contigs.bam',fasta_file))

# find all the SAG genomes
sag_genome_fasta_files = glob.glob(data_dir + "/*/IMG*/*assembled.fna")
sag_genomes = {re.search(r'\[([^\]]+)\]/', f).group(1):f for f in sag_genome_fasta_files}

rule output:
    input:
        reads=expand('{sag}/matching_reads_from_all_mgs.fastq', \
                     sag=sag_genomes),
        contigs=expand('{sag}/matching_contigs_from_all_mgs.fna', sag=sag_genomes)

rule list_matching_contigs:
    input: '{sag}/matching_contigs_from_mg.{mg}.lastal'
    output: '{sag}/matching_contigs_from_mg.{mg}.list'
    shell: 'filter_blast_m8.py -f blast --nonoverlapping -B 1000 {input} | cut -f 2 > {output}'

rule lastdb:
    input: '{fasta}'
    output: '{fasta}.prj'
    shell: 'lastdb -v {wildcards.fasta} {wildcards.fasta}'

rule find_matching_contigs:
    input:
        fasta=lambda w: sag_genomes[w.sag],
        db=lambda w:'{}.prj'.format(mg_genomes[w.mg])
    output:
        '{sag}/matching_contigs_from_mg.{mg}.lastal'
    params:
        db=lambda w: mg_genomes[w.mg]
    threads:
        config.get('lastal_threads', 20)
    shell:
        'lastal -F BlastTab {params.db} {input.fasta} > {output}'

rule matching_contigs_bed:
    input: 
        list='{sag}/matching_contigs_from_mg.{mg}.list',
        fasta=lambda w: mg_genomes[w.mg]
    output: '{sag}/matching_contigs_from_mg.{mg}.bed'
    shell: "grep '^>' {input.fasta} | perl -pe 's/^>(\\S+)\\s.+length_(\\d+)_.+/\\1\\t1\\t\\2/' | screen_table.py -l {input.list} -k  > {output}"

rule matching_contigs_fna:
    input:
        list='{sag}/matching_contigs_from_mg.{mg}.list',
        fna=lambda w: mg_genomes[w.mg]
    output: '{sag}/matching_contigs_from_mg.{mg}.fna'
    shell: 'screen_list.py {input.fna} -l {input.list} -k -o {output}'

rule all_mg_contigs_for_sag:
    input:
        expand('{{sag}}/matching_contigs_from_mg.{mg}.fna', mg=mg_genomes)
    output: '{sag}/matching_contigs_from_all_mgs.fna'
    shell: 'cat {input} > {output}'

rule sam_header_only:
    input: '{some_file}.bam'
    output: '{some_file}.bam.header'
    shell: 'samtools view -H {input} > {output}'

rule mg_read_list_for_sag:
    input:
        bams=lambda w: mg_bams[w.mg],
        bed='{sag}/matching_contigs_from_mg.{mg}.bed'
    output: '{sag}/matching_reads_from_mg.{mg}.list'
    shell:
        """
        rm -f {output}
        for BAM in {input.bams}; do
            samtools view -L {input.bed} $BAM | cut -f 1 >> {output}
        done
        """

rule mg_reads_for_sag:
    """
    USes screen table (will match multiple reads with same name) to pull out
    SAM lines.

    Takes advantage of BWA output using only the 4 and 16 flags in the second column
    so that the sourted output will alwaus put fwd before rev reads.
    """
    input:
        bams=lambda w: mg_bams[w.mg],
        reads='{sag}/matching_reads_from_mg.{mg}.list'
    output: '{sag}/matching_reads_from_mg.{mg}.fastq'
    shell:
        r"""
        rm -f {output}
        for BAM in {input.bams}; do
            samtools view $BAM | screen_table.py -l {input.reads} | sort | perl -lane 'print "\@$F[0]\n$F[9]\n+\n$F[10]";' >> {output}
        done
        """

rule all_mg_reads_for_sag:
    input:
        expand('{{sag}}/matching_reads_from_mg.{mg}.fastq', mg=mg_genomes)
    output: '{sag}/matching_reads_from_all_mgs.fastq'
    shell: 'cat {input} > {output}'
