"""
Called by annotation.gene_catalog.snake to build up the catalog from individual assemblies.

Starting point:
   multiple assembled metagenomes (configured in configfile) 

Workflow:
 * collect all faa and fna annotations
 * pull out just coding sequences from fna files
 * cluster all nucl CDS at 95%
 * pull out faa version of cluster reps
"""

#########
# CONFIGURATION
#
# assemblies located in paths
# listed in config[assembly_list] or file config[assembly_list_file]
if "assembly_list" not in config:
    with open(config['assembly_list_file']) as LIST:
        config['assembly_list'] = [l.strip() for l in LIST.readlines()]

# some assemblies need to be renamed to fit in the big catalog
# listed in config as list of 2-entry dicts:
# assembly_renaming:
#   - assembly: /full/path/to/assembly
#     regex: "s/old_prefix/new_prefix/"
#   - assembly: . . .
# Change to a simple dict for use in makefile
assembly_renaming_map = {x['assembly']:x['regex'] \
                         for x in config.get('assembly_renaming', [])}
# chose clustering method
#  clustering snake file should define the variable cluster_suffix
clustering_method = config.get('clustering_method', 'cdhit')
cluster_suffix = clustering_method
include: "anntation/gene_catalog.{}.snake".format(clustering_method)
#
# Define some trasitions to break the workflow up into segments
transitions = config.setdefault('transitions',{})
# the first part creates the clustered faa (prefix defined in parent makefile)
transitions[prefix + '.faa'] = \
            'all_genes.ffn.{}.faa'.format(cluster_suffix)
# the clustered ffn is ambiguously named, so lets add ffn to the end
transitions['all_genes.ffn.{}.ffn'.format(cluster_suffix) = \
            'all_genes.ffn.{}'.format(cluster_suffix)
#
# End configuration
##########

##########
# set up list of files to create
#  - The final tabulations
#  - Stats and histrogram files for fasta files
#  - The final annotation table
catalog_stats_files = \
                expand("stats/{prefix}.{suffix}.{ext}", 
                       ext=['stats','hist'],
                       suffix=['faa','fna'],
                       prefix="all_genes")
config['outputs'] = set(catalog_stats_files)
#
#########

#########
# Helper functions
                                                   
def get_all_gene_call_files(wildcards):
    """
    Find the contig.annotations.{wildcards.ext} for each assembly

    Replace file name with renamed file name if assembly needs 
    renaming

    Defaults to using unfiltered gene calls
    """
    ext = wildcards.ext
    # hack for sliding in fixed gene calls
    path_prefix = config.setdefault('gene_path_prefix', '')
    gene_file_root = config.get('gene_file_root', 'contigs.all.annotations')
    if 'gene_path_prefix' in config and ext=='fna':
        ext='ffn'

    for assembly_path in config['assembly_list']:
        file_name = os.path.join(path_prefix + assembly_path, 
                                 '{}.{}'.format(gene_file_root, ext))

        if assembly_path in assembly_renaming_map:
            file_name = "renamed_dir" + file_name

        yield file_name

def get_assembly_coverage_files(wildcards):
    """
    Find all the contig.coverages.{sample}.txt for each assembly
    """
    for assembly_path in config['assembly_list']:
        for file_name in glob.glob(os.path.join(assembly_path,
                                'contigs.final.stats.txt')):
            if assembly_path in assembly_renaming_map:
                file_name = "renamed_dir" + file_name
            yield file_name

def get_assembly_read_stats(wildcards):
    """
    Find all the cleaned reads stats files for each assembly
    """
    for assembly_path in config['assembly_list']:
        for file_name in glob.glob(os.path.join(assembly_path,
                                'stats',
                                '*.trimmed.dropse.fastq.stats')):
            yield file_name

##########
# RULES:
#  This lays out the dependencies and logic of the workflow

## First we collect the genes and cluster them

rule rename_contigs_and_genes:
    """ Renames contigs and genes in any annotation file that needs it """
    input: "{assembly}/{annotation_file}.{ext}"
    output: temp("renamed_dir{assembly}/{annotation_file}.{ext}")
    benchmark: 'benchmarks/rename_annotations{assembly}/{annotation_file}.{ext}.time'
    wildcard_constraints:
        ext='(faa|fna|ffn|txt)'
    params:
        regex=lambda w: assembly_renaming_map[re.sub('^' + \
                            config['gene_path_prefix'], '', \
                            w.assembly)]
    shell: "perl -pe '{params.regex}' \
            < {input} \
            > {output}"

rule collect_gene_calls:
    input: get_all_gene_call_files
    output: "all_genes.{ext}"
    benchmark: 'benchmarks/all_genes.{ext}.time'
    wildcard_constraints:
        ext=r'(fna|faa)'
    shell:
        """
        cat {input} > {output}
        """

rule get_fasta_id_list:
    input: "{file_root}.{ext}"
    output: "{file_root}.{ext}.idlist"
    benchmark: 'benchmarks/{file_root}.{ext}.idlist.time'
    wildcard_constraints:
        ext=r'(fna|ffn|faa|fasta|fa)'
    shell:
        r"""
        grep "^>" {input} \
         | perl -pe 's/>(\S+)\s.+/\1/' \
         | sort \
         | uniq \
         > {output}
        """

rule filter_fna:
    input:
        "all_genes.faa.idlist",
        "all_genes.fna"
    output: 
        "all_genes.ffn"
    benchmark: 'benchmarks/all_genes.ffn.time'
    shell: "screen_list.py -l {input[0]} -k {input[1]} > {output}"

rule get_cluster_rep_faa:
    input:
        "all_genes.ffn.{cd_hit_output_str}.ffn.idlist",
        "all_genes.faa"
    output:
        "all_genes.ffn.{cd_hit_output_str}.faa"
    benchmark:
        "benchmarks/all_genes.ffn.{cd_hit_output_str}.faa.time"
    shell: "screen_list.py -l {input[0]} -k {input[1]} > {output}"

## We also need to collect the contig coverages
rule get_gene_coverages:
    input: 
        contig_covs=get_assembly_coverage_files,
        read_stats=get_assembly_read_stats,
        gene_list="{}.faa.idlist".format(prefix)
    output: '{}.coverage.tsv'.format(prefix)
    benchmark: 'benchmarks/{}.coverage.tsv.time'.format(prefix)
    run:
        # get map from contig name to genes
        contig_genes = {}
        contig_rexp = re.compile(r'_\d+$')
        with open(get_file_name(input.gene_list)) as GENES:
            for gene in GENES:
                gene = gene.strip()
                contig = contig_rexp.sub('', gene)
                contig_genes.setdefault(contig, []).append(gene)

        with open(get_file_name(output), 'wt') as OUT:
            for contig, coverage in gene_catalog.normalize_coverages(input):
                for gene in contig_genes.get(contig, []):
                    OUT.write('{}\t{}\n'.format(gene, coverage))
