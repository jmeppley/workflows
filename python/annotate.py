"""
Functions for the annotation workflows
"""
import os
import re
from snakemake.logging import logger

def get_db_types(config):
    """ returns vailable db types """
    gene_family_dbs = []
    taxdb = None
    for db in config['dbs']:
        db_type = config['dbs'][db].get('type','gene')
        if db_type[0:3] == 'tax':
            taxdb=db
        elif db_type == 'gene':
            gene_family_dbs.append(db)
    return (gene_family_dbs, taxdb)

def get_last_alg(dbformat, extension):
    """
    right now looks for last db type (lastp or lastn) and extension (faa or
    not) and returns lastp, lastx, or lastn.

    Support for other dbs can be added on request.
    """
    if dbformat == 'lastp':
        if extension == 'faa':
            search_alg = 'lastp'
        else:
            search_alg = 'lastx'
    elif dbformat == 'lastn':
        if extension == 'faa':
            raise Exception("I'm sorry, I don't know how to search for faa "
                            "sequences in a lastp database!")
        else:
            search_alg = 'lastn'
    elif dbformat == 'bwadb':
        search_alg = 'bwa.sam'
    else:
        raise Exception(("I'm sorry, but the database format '{}' is not yet "
                         "supported").format(dbformat))
    return search_alg


def get_db_dot_fmt_strings(db_list, config, query_extension='fasta'):
    """
    Return a list of strings that are "{db}.{format}". Where db is the name of the database and format is the extension generated by the search (eg lastx, or tbl). There is a special case for fragmented HMM dbs where we need to add ".dbatch" to the format.
    """
    strings=[]
    for d in db_list:
        db_data = config['dbs'][d]
        format = db_data.get('format','tbl')
        if format.startswith('last'):
            format = get_last_alg(format, query_extension)
        if 'frags' in db_data and int(db_data['frags'])>1:
            format = format + ".dbatch"
        strings.append("{}.{}".format(d,format))
    return strings


def get_hit_table_name_from_wildcards_db(wildcards, config):
    """
    Return the hit table name based on the db name using the db config info
    """
    db=wildcards.db
    db_format=config['dbs'][db].get('format','hmmer')
    if db_format=='hmmer':
        if 'frags' in config['dbs'][db]:
            template = "{name_root}.vs.{db}.tbl.dbatch"
        else:
            template = "{name_root}.vs.{db}.tbl"
    elif db_format=='lastdb':
        template = "{name_root}.vs.{db}.lastp"
    else:
        # Don't know what to do:
        raise Exception("Unknown database format for {}: {}".format(db,db_format))

    name_root = config['annotation_hit_table_map']\
                        .get(wildcards.annotation_prefix,
                             wildcards.annotation_prefix)

    return template.format(name_root=name_root, **wildcards)


def get_db_assignment_params(wildcards, config):
    """
    return the params needed to turn hits from the given db (wildcards.db) into gene family assignments 
    using the assign_paths.py script
    """
    assign_type = config['dbs'][wildcards.db].get('assign_type','hitid').lower()
    if assign_type=='kegg':
        return '-p hitid -M kegg -m %s.kos' % (config['dbs'].get('KEGG',{'path':''})['path'])
    if assign_type=='pfam':
        return '-p pfam'
    return '-p hitid'


def get_db_frag(config, db, N):
    full_hmm = config['dbs'][db]['path']
    n_frags = config['dbs'][db]['frags']
    template = get_db_frag_template(full_hmm, n_frags)
    return template.format(N=int(N))

def get_db_frag_template(full_hmm, n_frags):
    n_frag_digits = 3  # unless we can get the hard coded 000 out of the rules
    #n_frag_digits = len(str(n_frags))
    hmm_dir = os.path.dirname(full_hmm)
    frag_dir = os.path.join(hmm_dir, 'frag_{}'.format(n_frags))
    hmm_base, hmm_ext = os.path.splitext(os.path.basename(full_hmm))
    template = "{}{}{}.{{N:0{}d}}{}".format(frag_dir, os.path.sep,
                                            hmm_base, n_frag_digits,
                                            hmm_ext)
    return template

def get_db_frags(full_hmm, n_frags):
    template = get_db_frag_template(full_hmm, n_frags)
    return [template.format(N) for N in range(1, n_frags+1)]

##
# rRNA/Silva

BLANK_FILE_NAME = ".empty.file"
RNA_SEARCH_HITS_TEMPLATE = \
    "contigs.all.vs.rRNA.cmsearch.{rmol}.gt{length}.gff.vs.{db_dot_fmt}"

def get_rna_search_hits(wildcards, config,
                        blank_file_name=BLANK_FILE_NAME,
                        rna_search_hits_template=RNA_SEARCH_HITS_TEMPLATE,
                       ):
    """ return search result that matches
    rmol (SSU or LSU) in wildcards.mol"""
    database = find_db_by_mol(wildcards.rmol, config)
    if database is not None:
        db_data = config['dbs'][database]
        fmt = db_data.get('format', 'lastdb')
        fmt = get_last_alg(fmt, 'fna')
        db_dot_fmt = "{}.{}".format(database, fmt)
        hits_file = rna_search_hits_template \
                                    .format(db_dot_fmt=db_dot_fmt,
                                            length=wildcards.length,
                                            rmol=wildcards.rmol)
        logger.debug("returning " + hits_file)
        return hits_file
    logger.debug("returing blank file")
    return blank_file_name

def get_rna_id_names_file(wildcards, config, \
                          blank_file_name=BLANK_FILE_NAME):
    """ get the .ids file from the Silva db
        # if rRNA DBs configured, this is a map to id/desc dict
        # otherwise put blank place holder """
    database = find_db_by_mol(wildcards.rmol, config)
    if database is not None:
        path = get_db_ids_file(database, config)
        logger.debug("returning " + path)
        return path
    logger.debug("returing blank file")
    return blank_file_name

def find_db_by_mol(mol, config):
    " search the configured dbs for given rRNA molecule db "
    for database, db_data in config.get('dbs', {}).items():
        if db_data.get('type') == 'rrna':
            if re.search(mol, database):
                return database
    return None

def get_db_ids_file(database, config):
    "get the ids file for a db. check db['ids'] then add .ids to path"
    if 'ids' in config['dbs'][database]:
        return config['dbs'][database]['ids']
    return config['dbs'][database]['path'] + ".ids"
